<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Introduzione al Multithreading (Java) — 4ª superiore</title>
  <link rel="stylesheet" href="style.css?v=3">
</head>
<body>
  <header class="header">
    <div class="container hero">
      <span class="badge">Unità didattica · Programmazione concorrente</span>
      <h1 class="title">Introduzione al <span style="color:var(--accent)">Multithreading</span> & Interleaving</h1>
      <p class="subtitle">Cosa significa eseguire più compiti in parallelo, perché è utile e quali rischi comporta.</p>
    </div>
  </header>

  <main class="container main">

    <section class="section">
      <div class="section-inner">
        <h2>Obiettivi della lezione</h2>
        <ul>
          <li>Capire cos'è un <strong>thread</strong> e perché si usa il <strong>multithreading</strong>.</li>
          <li>Intuire cos'è l'<strong>interleaving</strong> (l'intreccio delle istruzioni dei thread).</li>
          <li>Vedere un esempio di <strong>race condition</strong> e come evitarla.</li>
        </ul>
        <p class="callout">Nota: in Java ogni oggetto ha un <em>monitor</em> (un piccolo lucchetto) che può proteggere sezioni di codice condivise via <code>synchronized</code>.</p>
      </div>
    </section>

    <section class="section">
      <div class="section-inner">
        <h2>Cos'è il multithreading?</h2>
        <p>Il <strong>multithreading</strong> è la capacità di un programma di eseguire parti del lavoro in <em>più thread</em>, potenzialmente in parallelo (su più core) o in concorrenza (sullo stesso core con cambio rapido di contesto).</p>
        <ul>
          <li><strong>Perché usarlo?</strong> sfruttare CPU multi-core, mantenere UI reattive, eseguire I/O in background.</li>
          <li><strong>Costi</strong>: coordinamento tra thread, bug difficili (race, deadlock), misurazioni non banali (warm-up della JVM).</li>
        </ul>
        <p class="callout ok"><strong>Esempi</strong>: sommare velocemente un grande vettore dividendo il lavoro tra più thread; scaricare file in parallelo; elaborare immagini a blocchi.</p>
      </div>
    </section>

    <section class="section wide">
      <div class="section-inner">
        <h2>Che cos'è l'interleaving?</h2>
        <p><strong>Interleaving</strong> = l'ordine <em>imprevedibile</em> con cui le istruzioni di thread diversi vengono effettivamente eseguite. Anche su un singolo core la CPU alterna i thread così velocemente che il risultato è un "intreccio" di operazioni.</p>
		<table class="interleave">
		  <caption>Interleaving che può causare race (risultato finale = 1)</caption>
		  <thead>
			<tr><th>Tempo →</th><th>T1</th><th>T2</th><th>T3</th><th>T4</th><th>T5</th><th>T6</th></tr>
		  </thead>
		  <tbody>
			<tr><td>A</td><td>read x=0</td><td></td><td>add 1</td><td></td><td>write 1</td><td></td></tr>
			<tr><td>B</td><td></td><td>read 0</td><td></td><td>add 1</td><td></td><td>write 1</td></tr>
		  </tbody>
		</table>

		<table class="interleave">
		  <caption>Sequenza senza interleaving “sfortunato” (risultato finale = 2)</caption>
		  <thead>
			<tr><th>Tempo →</th><th>T1</th><th>T2</th><th>T3</th><th>T4</th><th>T5</th><th>T6</th></tr>
		  </thead>
		  <tbody>
			<tr><td>A</td><td>read x=0</td><td>add 1</td><td>write 1</td><td></td><td></td><td></td></tr>
			<tr><td>B</td><td></td><td></td><td></td><td>read 1</td><td>add 1</td><td>write 2</td></tr>
		  </tbody>
		</table>

        <p class="callout bad"><strong>Race condition</strong>: se A e B aggiornano la stessa variabile senza protezione, il risultato può essere <em>1</em> invece di <em>2</em> a causa dell'interleaving.</p>
      </div>
    </section>

    <section class="section">
      <div class="section-inner">
        <h2>Mini-esperimento: somma "rotta"</h2>
        <p>Questo codice mostra una somma globale aggiornata da più thread <em>senza sincronizzazione</em>. Eseguilo più volte: il risultato cambia.</p>
        <pre class="code"><code>class RaceDemo {
  static long total = 0;           // variabile condivisa (non protetta!)
  public static void main(String[] args) throws Exception {
    long[] a = java.util.stream.LongStream.range(0, 1_000_00).toArray();
    Thread t1 = new Thread(() -> { for (long v : a) total += v; });
    Thread t2 = new Thread(() -> { for (long v : a) total += v; });
    t1.start(); t2.start(); t1.join(); t2.join();
    System.out.println("Risultato (sbagliato spesso): " + total);
  }
}
</code></pre>
        <p class="callout warn">Per accentuare l'interleaving in laboratorio, inserisci saltuariamente <code>Thread.yield()</code> o <code>Thread.sleep(1)</code> dentro i loop.</p>
      </div>
    </section>

    <section class="section">
      <div class="section-inner">
        <h2>Come si evita la race?</h2>
        <ul>
          <li><strong>Mutua esclusione</strong> con <code>synchronized</code> (usa il monitor di un oggetto).</li>
          <li><strong>Primitive atomiche</strong> (es. <code>AtomicLong</code>).</li>
          <li><strong>Riduzione delle contese</strong>: calcoli locali per thread + combinazione finale.</li>
        </ul>
        <pre class="code"><code>// Esempio: somma locale per thread (nessuna contesa durante il lavoro)
long sumLocal(long[] a, int T) throws InterruptedException {
  long[] partial = new long[T];
  Thread[] th = new Thread[T];
  int n = a.length, block = (n + T - 1)/T;
  for (int t = 0; t < T; t++) {
    final int id = t, start = t*block, end = Math.min(n, start+block);
    th[t] = new Thread(() -> {
      long s = 0; for (int i = start; i < end; i++) s += a[i];
      partial[id] = s; // una sola scrittura condivisa
    });
    th[t].start();
  }
  for (Thread x : th) x.join();
  long total = 0; for (long p : partial) total += p; return total;
}
</code></pre>
      </div>
    </section>

    <section class="section wide">
      <div class="section-inner">
        <h2>Misurare correttamente</h2>
        <ul>
          <li><strong>Warm-up JVM</strong>: le prime esecuzioni sono più lente (JIT in riscaldamento). Ripeti i test e prendi la media.</li>
          <li>Prova con dimensioni crescenti del problema e diversi numeri di thread (1, 2, 4, 8).</li>
          <li>Se il problema è piccolo, il multithreading può essere <em>più lento</em> a causa dell'overhead.</li>
        </ul>
      </div>
    </section>
  </main>

  <footer class="footer">
    <div class="container">© 2025 · Prof. Marco Cocciniglia · Lezione: Introduzione al Multithreading. In caso di dubbi, chiedete senza esitare.</div>
  </footer>
</body>
</html>
```
